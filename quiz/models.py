from django.db import models
from django.contrib.auth.models import AbstractUser
from django.utils import timezone
import json


class CustomUser(AbstractUser):
    """
    Custom user model extending Django's AbstractUser.
    Adds additional fields for quiz platform functionality.
    """
    total_score = models.IntegerField(default=0, help_text="Total accumulated score across all games")
    games_played = models.IntegerField(default=0, help_text="Number of games played")
    win_rate = models.FloatField(default=0.0, help_text="Win rate percentage")
    avatar = models.ImageField(upload_to='avatars/', blank=True, null=True, help_text="User avatar image")

    def update_stats(self, score, won=False):
        """Update user statistics after a game"""
        self.total_score += score
        self.games_played += 1
        if won:
            self.win_rate = ((self.win_rate * (self.games_played - 1)) + 100) / self.games_played
        else:
            self.win_rate = (self.win_rate * (self.games_played - 1)) / self.games_played
        self.save()

    class Meta:
        verbose_name = "User"
        verbose_name_plural = "Users"


class Question(models.Model):
    """
    Model representing a quiz question.
    Questions can be generated by AI or manually created.
    """
    QUESTION_TYPES = [
        ('multiple_choice', 'Multiple Choice'),
        ('true_false', 'True/False'),
        ('coding', 'Coding Challenge'),
    ]

    DIFFICULTY_LEVELS = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]

    question_text = models.TextField(help_text="The question text")
    question_type = models.CharField(max_length=20, choices=QUESTION_TYPES, default='multiple_choice')
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_LEVELS, default='medium')
    options = models.JSONField(blank=True, null=True, help_text="Multiple choice options (for multiple_choice type)")
    correct_answer = models.TextField(help_text="The correct answer")
    explanation = models.TextField(blank=True, null=True, help_text="Explanation of the correct answer")
    category = models.CharField(max_length=100, blank=True, null=True, help_text="Question category/topic")
    created_at = models.DateTimeField(auto_now_add=True)
    is_ai_generated = models.BooleanField(default=False, help_text="Whether this question was generated by AI")

    def __str__(self):
        return f"{self.question_type}: {self.question_text[:50]}..."

    def is_correct(self, answer):
        """Check if the provided answer is correct"""
        # Handle None or empty answer
        if answer is None or answer == '':
            return False
        # Normalize stored correct_answer to int when possible
        try:
            if isinstance(self.correct_answer, int):
                # allow answer as int or numeric string
                try:
                    return int(answer) == self.correct_answer
                except Exception:
                    return False

            if isinstance(self.correct_answer, str):
                # if stored as a digit string, compare numerically
                if self.correct_answer.isdigit():
                    try:
                        return int(answer) == int(self.correct_answer)
                    except Exception:
                        return False
                # otherwise compare as strings (case-insensitive)
                try:
                    return str(answer).strip().lower() == self.correct_answer.strip().lower()
                except Exception:
                    return False

        except Exception:
            return False

        return False


class QuizSession(models.Model):
    """
    Model representing a quiz session (single-player or multiplayer).
    """
    SESSION_TYPES = [
        ('single', 'Single Player'),
        ('multiplayer', 'Multiplayer'),
        ('coding_battle', 'Coding Battle'),
    ]

    STATUS_CHOICES = [
        ('waiting', 'Waiting for Players'),
        ('active', 'Active'),
        ('finished', 'Finished'),
    ]

    session_type = models.CharField(max_length=20, choices=SESSION_TYPES, default='single')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='waiting')
    created_at = models.DateTimeField(auto_now_add=True)
    started_at = models.DateTimeField(blank=True, null=True)
    finished_at = models.DateTimeField(blank=True, null=True)
    max_players = models.IntegerField(default=1, help_text="Maximum number of players allowed")
    current_question_index = models.IntegerField(default=0, help_text="Current question being displayed")
    time_limit = models.IntegerField(default=15, help_text="Time limit per question in seconds")
    difficulty_level = models.CharField(max_length=10, default='mixed', help_text="Difficulty level of the session")
    questions = models.ManyToManyField(Question, through='SessionQuestion', help_text="Questions in this session")

    def __str__(self):
        return f"{self.session_type} Session {self.id} - {self.status}"

    def start_session(self):
        """Mark the session as started"""
        self.status = 'active'
        self.started_at = timezone.now()
        self.save()

    def end_session(self):
        """Mark the session as finished"""
        self.status = 'finished'
        self.finished_at = timezone.now()
        self.save()

    def get_current_question(self):
        """Get the current question being displayed"""
        try:
            return self.sessionquestion_set.get(order=self.current_question_index).question
        except SessionQuestion.DoesNotExist:
            return None

    def next_question(self):
        """Move to the next question"""
        self.current_question_index += 1
        self.save()
        return self.get_current_question()


class SessionQuestion(models.Model):
    """
    Through model for QuizSession and Question with ordering.
    """
    session = models.ForeignKey(QuizSession, on_delete=models.CASCADE)
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    order = models.IntegerField(help_text="Order of the question in the session")

    class Meta:
        unique_together = ('session', 'order')
        ordering = ['order']


class PlayerScore(models.Model):
    """
    Model tracking individual player scores in a quiz session.
    """
    player = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    session = models.ForeignKey(QuizSession, on_delete=models.CASCADE)
    score = models.IntegerField(default=0, help_text="Current score in the session")
    correct_answers = models.IntegerField(default=0, help_text="Number of correct answers")
    total_answers = models.IntegerField(default=0, help_text="Total number of answers given")
    joined_at = models.DateTimeField(auto_now_add=True)
    last_activity = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('player', 'session')

    def __str__(self):
        return f"{self.player.username} - Session {self.session.id}: {self.score} points"

    def add_score(self, points):
        """Add points to the player's score"""
        self.score += points
        self.correct_answers += 1
        self.total_answers += 1
        self.save()

    def record_incorrect(self):
        """Record an incorrect answer"""
        self.total_answers += 1
        self.save()

    @property
    def accuracy(self):
        """Calculate answer accuracy percentage"""
        if self.total_answers == 0:
            return 0.0
        return (self.correct_answers / self.total_answers) * 100


class CodeSubmission(models.Model):
    """
    Model for code submissions in coding battles.
    """
    STATUS_CHOICES = [
        ('pending', 'Pending Evaluation'),
        ('running', 'Running'),
        ('passed', 'Passed'),
        ('failed', 'Failed'),
        ('error', 'Error'),
    ]

    player = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    session = models.ForeignKey(QuizSession, on_delete=models.CASCADE)
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    code = models.TextField(help_text="Submitted code")
    language = models.CharField(max_length=20, default='python', help_text="Programming language")
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    execution_time = models.FloatField(blank=True, null=True, help_text="Execution time in seconds")
    memory_used = models.IntegerField(blank=True, null=True, help_text="Memory used in KB")
    output = models.TextField(blank=True, null=True, help_text="Program output")
    error_message = models.TextField(blank=True, null=True, help_text="Error message if any")
    submitted_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.player.username} - {self.question.question_text[:30]}... ({self.status})"

    def run_code(self):
        """Execute the submitted code and update status"""
        # This is a placeholder - in a real implementation, you'd use a secure code execution service
        self.status = 'running'
        self.save()

        try:
            # Simple execution for demonstration (NOT SECURE for production)
            import subprocess
            import tempfile
            import os

            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                f.write(self.code)
                temp_file = f.name

            try:
                result = subprocess.run(
                    ['python', temp_file],
                    capture_output=True,
                    text=True,
                    timeout=10  # 10 second timeout
                )

                self.output = result.stdout
                if result.stderr:
                    self.error_message = result.stderr

                if result.returncode == 0:
                    self.status = 'passed'
                else:
                    self.status = 'failed'

            except subprocess.TimeoutExpired:
                self.status = 'error'
                self.error_message = 'Code execution timed out'
            except Exception as e:
                self.status = 'error'
                self.error_message = str(e)

        finally:
            # Clean up temp file
            if os.path.exists(temp_file):
                os.unlink(temp_file)

        self.save()


class CodingProblem(models.Model):
    """Model for specific coding battle problems."""
    DIFFICULTY_LEVELS = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]
    title = models.CharField(max_length=200)
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_LEVELS)
    description = models.TextField()
    input_format = models.TextField()
    output_format = models.TextField()
    test_cases = models.JSONField(help_text="List of test cases")
    starter_code = models.TextField(blank=True, null=True, help_text="Initial code for the user")
    
    def __str__(self):
        return f"{self.title} ({self.difficulty})"


class CodingBattle(models.Model):
    """Model representing a 1v1 coding battle session."""
    problem = models.ForeignKey(CodingProblem, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(blank=True, null=True)
    
    def __str__(self):
        return f"Battle {self.id} - {self.problem.title}"


class PlayerSubmission(models.Model):
    """Model for player submissions in a coding battle."""
    battle = models.ForeignKey(CodingBattle, on_delete=models.CASCADE)
    player_index = models.IntegerField(help_text="1 or 2")
    language_id = models.IntegerField()
    source_code = models.TextField()
    passed_count = models.IntegerField(default=0)
    total_tests = models.IntegerField(default=0)
    runtime = models.FloatField(default=0.0, help_text="Max runtime in seconds")
    completed_at = models.DateTimeField(auto_now_add=True)
    status_text = models.CharField(max_length=50, default="Pending")
    
    def __str__(self):
        return f"Battle {self.battle.id} - Player {self.player_index} ({self.status_text})"
